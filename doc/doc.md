
## Usage ##
```lua
local host = arg[1] or '127.0.0.1'
local port = arg[2] or 514

-- this code run in separate thread.
local InitWriter = [[
  return require 'log.writer.list'.new(                  -- multi writers:
    require 'log.writer.console.color'.new(),            -- * console color
    require 'log.writer.net.zmq'.new('%{zmq_cnn_host}'), -- * zmq pub socket
    require "log.writer.format".new(                     -- * syslog over udp
      require "log.logformat.syslog".new("user"),
      require 'log.writer.net.udp'.new('%{udp_cnn_host}', %{udp_cnn_port})
    )
  )
]]

-- create async writer and run new work thread.
-- communicate with work thread using zmq library
local writer = require "log.writer.async.zmq".new(
  'inproc://async.logger', 
  InitWriter:gsub('%%{(.-)}', {
    zmq_cnn_host = 'tcp://' .. host .. ':' .. port;
    udp_cnn_host = host;
    udp_cnn_port = port;
  })
)

-- create new logger
local LOG = require"log".new(writer)

require "socket".sleep(0.5) -- net.zmq need time to connect

LOG.fatal("can not allocate memory")
LOG.error("file not found")
LOG.warning("cache server is not started")
LOG.info("new message is received")
LOG.notice("message has 2 file")

print("Press enter ...") io.flush() io.read()
```

## log library ##

`LVL` - enum of all supported log levels

`LVL_NAMES` - array of all names of log levels

`new([max_lvl,] writer [[,formatter] ,logformat])` create new `logger` object

### logger ###
this object provide user interface to logging system

`lvl` param can be number or string (eg. "error", "ERROR", log.LVL.ERROR)

* `logger.log(lvl, ...)` - write log message using logger's formatter
* `logger.dump(lvl, formatter, ...)` - write log message using fn as formatter
* `logger.writer()` - return current writer
* `logger.lvl()` - reutrn current log level
* `logger.set_lvl(lvl)` - set current log level

loggers writer methods have 2 forms:
* `logger.XXX(lvl, ...)` - this writers use formatter setted by constructor(eg. `logger.error`)
* `logger.XXX_dump(lvl, formatter, ...)` - this writers use explicit formatter (eg. `logger.trace_dump`)

list of writer methods:
* `emerg`   / `emerg_dump`
* `alert`   / `alert_dump`
* `fatal`   / `fatal_dump`
* `error`   / `error_dump`
* `warning` / `warning_dump`
* `notice`  / `notice_dump`
* `info`    / `info_dump`
* `debug`   / `debug_dump`
* `trace`   / `trace_dump`

### formatter ###
  convert all parameters passed to one of write methods (error/info/debug etc.) to string
  `XXX_dump` methods use explicit formatter.

  supported formatters:
  * `default`: use first argument only
  * `concat`: use table.concat
  * `format`: use string.format
  * `mix`: compatable with lualogging library

### logformat ###
  convert loglevel, datetime and message generated by formatter to string.
  logformat is called by writer not logger.

  supported formats:
  * `default`: make string like `datetime [LVL_NAME] message`
  * `proxy`: serialize args to string to pass them to another thread/process/host
  * `syslog`: make valide syslog message

### writer ###
  write message generated by logformat to storage.

  supported writers:
  * `net.*` syncronus writers that pass message across hosts (`udp`, `smtp`, `zmq.pub`, `zmq.push`, `zmq.srv.pub')
  * `file.*` syncronus writers that write message to file (`roll`, `by_day`).
    all this writers use common `file` writer.
  * `async.*` asyncronus writers that pass message to other thread/process/host
    this writers can create new thread or use existed. (`udp`,`zmq`,`lane`)
  * `async.server.*` this is not writers, but just way to start some syncronus writer in separate thread.
    for more detail see implementation of `async.*` writer.
  * `list` this writer provide way to pass message to multiple writers
  * `format` this writer provide way to set specific logformat for writer
    this can be used to combine syslog logformat and net.udp writer.
  * `filter.*` this writer provide way to filter some type of message(`lvl.eq`, `lvl.le`)
